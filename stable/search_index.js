var documenterSearchIndex = {"docs":
[{"location":"interface/#Interface","page":"Interface","title":"Interface","text":"","category":"section"},{"location":"interface/","page":"Interface","title":"Interface","text":"All grid types need to have a certain structure and implement a set of functions which will be discussed here.","category":"page"},{"location":"interface/#Overview","page":"Interface","title":"Overview","text":"","category":"section"},{"location":"interface/","page":"Interface","title":"Interface","text":"The interface is divided into common functions which do not need to be implemented for subtypes, since they rely on struct fields all subtypes need to have, and functions which need to be overloaded.","category":"page"},{"location":"interface/#Common-Types","page":"Interface","title":"Common Types","text":"","category":"section"},{"location":"interface/","page":"Interface","title":"Interface","text":"All actual k-grids are supposed to by abstract subtypes of GridType.  For example abstract type cP_2D <: GridType end (TODO: ref SC doc).  Each k-grid of type T <: GridType should than implement a NewKGrid <: FullKGrid{T} and NewReducedKGrid <: ReducedKGrid{T} <: structs. Both full and reduced k-grid types are subtypes of KGrid{T}. This hierarchy ensures a set of comon functionalities, that external modules can rely on. ","category":"page"},{"location":"interface/#Required-Fieds","page":"Interface","title":"Required Fieds","text":"","category":"section"},{"location":"interface/","page":"Interface","title":"Interface","text":"Internally, the structs also need to have at least the following fields:","category":"page"},{"location":"interface/#Common-Functions","page":"Interface","title":"Common Functions","text":"","category":"section"},{"location":"interface/","page":"Interface","title":"Interface","text":"The following functions are available for all grids, due to the common struct fields defined above.","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"TODO","category":"page"},{"location":"interface/#Interface-Functions","page":"Interface","title":"Interface Functions","text":"","category":"section"},{"location":"#Dispersions.jl","page":"Home","title":"Dispersions.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This project contains ","category":"page"},{"location":"#Description","page":"Home","title":"Description","text":"","category":"section"},{"location":"#Common-Functions","page":"Home","title":"Common Functions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The following functions are available for all grids.","category":"page"},{"location":"#Basic-access-functions","page":"Home","title":"Basic access functions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Convenience functions to access fields of k grid structs.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [Dispersions]\nPrivate = true\nOrder   = [:module, :constant, :type, :function, :macro]\n","category":"page"},{"location":"#Dispersions.KGrid","page":"Home","title":"Dispersions.KGrid","text":"KGrid{T <: KGridType, D}\n\nFields\n\nNk      : Int, Number of total k-points\nNs      : Int, Number of sampling points per dimension\nt       : Float64, hopping parameter\ntp      : Float64, hopping parameter, next nearest neighbor\ntpp     : Float64, hopping parameter, next next nearest neighbor\nkGrid   : Vector{NTuple{D,Float64}}, vector of k-points. Each element is a D-tuple\nϵkGrid  : Vector{Float64}, Dispersion relation\nkInd    : Vector{NTuple{D,Int}}, vector of indices mapping from the full to reduced lattice.\nkInd_conv    : Vector{NTuple{D,Int}}, vector of indices mapping from the full to reduced lattice after convolution (this incorporates possible reorderings).\nkInd_crossc   : Vector{NTuple{D,Int}}, vector of indices mapping from the full to reduced lattice after crosscorrelation (this incorporates possible reorderings).\nkMult   : Vector{Int}, multiplicity per k-point in reduced lattice\nexpand_perms : Vector{NTuple{D, Int}}, mapping of each k-point in reduced lattice to full lattice points\nexpand_cache : Array{ComplexF64}, internal cache for expansion of reduced to full lattice before executing convolutions\nconv_cache   : Array{ComplexF64,D}, innternal cache for convolutions\nfftw_plan    : FFTW.cFFTWPlan, fft plan to be executed in convolutions. WARNING: This field can not be serialized right now and needs to be reconstructed after reading a KGrid from disk.\n\n\n\n\n\n","category":"type"},{"location":"#Dispersions.Nk-Tuple{Any}","page":"Home","title":"Dispersions.Nk","text":"Nk(kG::T) where T <: KGrid\n\nTotal number of k points (length of kGrid.kGrid for full grids). \n\n\n\n\n\n","category":"method"},{"location":"#Dispersions.conv!-Tuple{KGrid, AbstractVector{ComplexF64}, AbstractVector{ComplexF64}, AbstractVector{ComplexF64}}","page":"Home","title":"Dispersions.conv!","text":"conv!(kG::KGrid, res::AbstractVector{ComplexF64}, arr1::AbstractVector{ComplexF64}, arr2::AbstractVector{ComplexF64})\n\nInplace version of conv. The results are written to res.\n\n\n\n\n\n","category":"method"},{"location":"#Dispersions.conv-Tuple{KGrid, AbstractVector{ComplexF64}, AbstractVector{ComplexF64}}","page":"Home","title":"Dispersions.conv","text":"conv(kG::KGrid, arr1::AbstractVector{ComplexF64}, arr2::AbstractVector{ComplexF64})\n\nComputes the convolution with a plus sign of data over two arrays arr1 and arr2, i.e. resk = sum_q in textBZ arr1k * arr2k+q.\n\ncrosscorrelation sets the sign of the 'convolution' to +, i.e. sum_j f_i g_i+j instead of sum_j f_i g_i-j.\n\n\n\n\n\n","category":"method"},{"location":"#Dispersions.conv_fft!-Tuple{KGrid, AbstractVector{ComplexF64}, AbstractArray{ComplexF64}, AbstractArray{ComplexF64}}","page":"Home","title":"Dispersions.conv_fft!","text":"conv_fft!(kG::KGrid, res::AbstractVector{ComplexF64}, arr1::AbstractVector{ComplexF64}, arr2::AbstractVector{ComplexF64})\n\nInplace version of conv_fft.\n\n\n\n\n\n","category":"method"},{"location":"#Dispersions.conv_fft-Tuple{KGrid, AbstractArray{ComplexF64}, AbstractArray{ComplexF64}}","page":"Home","title":"Dispersions.conv_fft","text":"conv_fft(kG::KGrid, res::AbstractVector{ComplexF64}, arr1::AbstractVector{ComplexF64}, arr2::AbstractVector{ComplexF64})\n\nVersion of conv for precomputed arr1 and arr2. Note, that reversing arr2 is also expected, see also conv_fft1, if crosscorrelation = true is assumed.\n\n\n\n\n\n","category":"method"},{"location":"#Dispersions.conv_fft1!-Tuple{KGrid, AbstractVector{ComplexF64}, AbstractVector{ComplexF64}, AbstractArray{ComplexF64}}","page":"Home","title":"Dispersions.conv_fft1!","text":"conv_fft1!(kG::KGrid, res::AbstractVector{ComplexF64}, arr1::AbstractVector{ComplexF64}, arr2::AbstractVector{ComplexF64})\n\nInplace version of conv_fft1.\n\n\n\n\n\n","category":"method"},{"location":"#Dispersions.conv_fft1-Tuple{KGrid, AbstractArray{ComplexF64}, AbstractArray{ComplexF64}}","page":"Home","title":"Dispersions.conv_fft1","text":"conv_fft1(kG::KGrid, res::AbstractVector{ComplexF64}, arr1::AbstractVector{ComplexF64}, arr2::AbstractVector{ComplexF64})\n\nVersion of conv for precomputed arr2. Note, that reversing the array is also expected, i.e. arr2 = fft(reverse(in_arr2)), if crosscorrelation = true is assumed.\n\n\n\n\n\n","category":"method"},{"location":"#Dispersions.conv_post!-Union{Tuple{T}, Tuple{KGrid, AbstractVector{T}, AbstractArray{T}}} where T","page":"Home","title":"Dispersions.conv_post!","text":"conv_post!(kG::KGrid{cP,D}, res::Array{T,1}, x::Array{T,D}) where {D,T}\n\nInplace version of conv_post. Warning: res should not alias kG.cache2 as some implementations may use this cache without explicitly checking for pointer aliases. \n\n\n\n\n\n","category":"method"},{"location":"#Dispersions.conv_post-Union{Tuple{T}, Tuple{D}, Tuple{KGrid, Array{T, D}}} where {D, T}","page":"Home","title":"Dispersions.conv_post","text":"conv_post(kG::KGrid, x::Array{T,D})\n\nPost convolution steps e.g. reversing or shifting the result. Some lattice types may overload this, depending on the sample points. See cP.jl for an example. crosscorrelation sets the sign for the convolution. See also  conv\n\n\n\n\n\n","category":"method"},{"location":"#Dispersions.conv_post_add!-Union{Tuple{T}, Tuple{KGrid, AbstractVector{T}, AbstractArray{T}}} where T","page":"Home","title":"Dispersions.conv_post_add!","text":"conv_post_add!(kG::KGrid{cP,D}, res::Array{T,1}, x::Array{T,D}) where {D,T}\n\nInplace version of conv_post, but add values instead of replacing them. Warning: res should not alias kG.cache2 as some implementations may use this cache without explicitly checking for pointer aliases. \n\n\n\n\n\n","category":"method"},{"location":"#Dispersions.conv_sample_post-Union{Tuple{D}, Tuple{KGrid{cP, D}, Any}} where D","page":"Home","title":"Dispersions.conv_sample_post","text":"conv_sample_post(kG::KGrid{cP,D}, x)\n\nThis is needed in case the sampling is not starting at 0, i.e. [0,V) × [0,V) ... in order to shift the 0 frequency to the appropriate sampling point.   \n\n\n\n\n\n","category":"method"},{"location":"#Dispersions.dispersion-Tuple{T} where T<:KGrid","page":"Home","title":"Dispersions.dispersion","text":"dispersion(kG::T)::Int where T <: KGrid\n\nReturns dispersion relation of grid.\n\n\n\n\n\n","category":"method"},{"location":"#Dispersions.expandKArr!-Tuple{KGrid, Vector{ComplexF64}}","page":"Home","title":"Dispersions.expandKArr!","text":"expandKArr!(kG, arr)\n\nInplace version of expandKArr. The results are written to kG.cache1.\n\n\n\n\n\n","category":"method"},{"location":"#Dispersions.expandKArr!-Union{Tuple{D}, Tuple{T}, Tuple{gT}, Tuple{KGrid{gT, D}, AbstractArray{T, D}, Vector{T}}} where {gT<:Dispersions.KGridType, T, D}","page":"Home","title":"Dispersions.expandKArr!","text":"expandKArr!(kG, [res,] arr)\n\nInplace version of expandKArr. The results are written to res.\n\n\n\n\n\n","category":"method"},{"location":"#Dispersions.expandKArr-Union{Tuple{D}, Tuple{T}, Tuple{gT}, Tuple{KGrid{gT, D}, AbstractVector{T}}} where {gT<:Dispersions.KGridType, T, D}","page":"Home","title":"Dispersions.expandKArr","text":"expandKArr(kGrid::KGrid, arr)\n\nTakes a kGrid kGrid and arbitrary data arr over a reduced BZ and returns an array with data over full BZ. This is mainly used before convolutions, since they require data over the full BZ.\n\n\n\n\n\n","category":"method"},{"location":"#Dispersions.gen_kGrid-Tuple{String, Int64}","page":"Home","title":"Dispersions.gen_kGrid","text":"gen_kGrid(kG::String, Ns::Int)\n\nGenerates a KGrid of type and hopping strength, given in kG with Ns sampling points in the first Brillouin zone. Options are:\n\n'3dcP-...'         : simple cubic 3D\n'2dcP-...'         : simple cubic 2D\n'2dcP-...-...-...' : simple cubic 2D with next-next nearest neighbor hopping\n'cF-...'           : FCC\n'cI-...'           : BCC\n\nExamples\n\njulia> gen_kGrid(\"3dcP-1.5\", 10)\ncP(t=1.5) grid in 3 dimensions with 1000 k-points.\n\n\n\n\n\n","category":"method"},{"location":"#Dispersions.gridPoints-Tuple{T} where T<:KGrid","page":"Home","title":"Dispersions.gridPoints","text":"gridPoints(kG::T)::Int where T <: KGrid\n\nk vektors for the given grid. Elements of the irreducible part only.\n\n\n\n\n\n","category":"method"},{"location":"#Dispersions.grid_dimension-Tuple{KGrid}","page":"Home","title":"Dispersions.grid_dimension","text":"grid_dimension(kG::KGrid)\n\nMaps the given grid onto its dimension.\n\nReturns:\n-------------\nD : `Int`, dimension of the reciprocal lattice space.\n\n\n\n\n\n","category":"method"},{"location":"#Dispersions.grid_type-Tuple{KGrid}","page":"Home","title":"Dispersions.grid_type","text":"grid_type(kG::KGrid)\n\nMaps the given grid onto its KGridType without the number of dimensions.\n\nReturns:\n\ntype : KGridType, type of the reciprocal lattice space, e.g. cP.\n\n\n\n\n\n","category":"method"},{"location":"#Dispersions.gridshape-Union{Tuple{KGrid{T, D}}, Tuple{D}, Tuple{T}} where {T, D}","page":"Home","title":"Dispersions.gridshape","text":"gridshape(kG::T) where T <: KGrid\n\nshape of kGrid (e.g. (kG.Ns, kG.Ns) for 2D cP) \n\n\n\n\n\n","category":"method"},{"location":"#Dispersions.reduceKArr!-Union{Tuple{D}, Tuple{T}, Tuple{gT}, Tuple{KGrid{gT, D}, AbstractVector{T}, AbstractArray{T, D}}} where {gT<:Dispersions.KGridType, T, D}","page":"Home","title":"Dispersions.reduceKArr!","text":"reduceKArr!(kGrid::KGrid, res, arr)\n\nInplace version of reduceKArr. The results are written to res.\n\n\n\n\n\n","category":"method"},{"location":"#Dispersions.reduceKArr-Union{Tuple{D}, Tuple{T}, Tuple{gT}, Tuple{KGrid{gT, D}, AbstractArray{T, D}}} where {gT<:Dispersions.KGridType, T, D}","page":"Home","title":"Dispersions.reduceKArr","text":"reduceKArr(kGrid::KGrid, arr)\n\nTakes a kGrid kGrid and arbitrary data arr over a full BZ and returns an array with data over fully irreducible BZ. This is mainly used after convolutions, since they require data over the full BZ.\n\n\n\n\n\n","category":"method"},{"location":"#Dispersions.ϵ_k_plus_q-Tuple{KGrid, Tuple{Vararg{T, N}} where {N, T}}","page":"Home","title":"Dispersions.ϵ_k_plus_q","text":"ϵ_k_plus_q(kG::KGrid, q::NTuple)\n\nEvaluates the dispersion relation on the given reciprocal space but expanded and shifted by a constant vector `q`. The corresponding points in reciprocal space are given by `expandKArr(kG, gridPoints(kG))`.\n\nReturns:\n\n`\\epsilon(k+\\mathrm{shift}):Vector{NTuple{D,Float64}}`, where D is the diemenion of the grid. Dispersion relation evaluated on the given grid but shifted by the the vector q.\n\nATTENTION: So far this function is tested for the simple cubic lattice only!\n\nArguments:\n\nkG       : reciprocal lattice\nq    : vector in reciprocal space\n\n\n\n\n\n","category":"method"}]
}
